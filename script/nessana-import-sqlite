#!/usr/bin/env ruby

# TODO Map to IP and DNS name
# TODO Persistence (migrations)

require 'active_record'
require 'bulk_insert'
require 'fastcsv'
require 'sqlite3'

# Use `binding.pry` anywhere in this script for easy debugging
require 'pp'
require 'pry'

# Connect to an in-memory sqlite3 database
ActiveRecord::Base.establish_connection(adapter: 'sqlite3', database: 'nessana.sqlite3')
# ActiveRecord::Base.logger = Logger.new(STDOUT)
# ActiveRecord::Base.logger.level = :debug

# Define a minimal database schema
ActiveRecord::Schema.define do
	create_table :scans do |t|
		t.string :filename
		t.string :sha512
	end unless table_exists?(:scans)

	create_table :detections do |t|
		t.belongs_to(:plugin, index: true)
		t.belongs_to(:scan, index: true)
		t.belongs_to(:host, index: true)
		t.binary :plugin_output
		t.integer :port
		t.string :protocol
	end unless table_exists?(:detections)

	create_table :plugins do |t|
		t.string :cve
		t.string :cvss
		t.string :risk
		t.string :name
		t.text :synopsis
		t.text :description
		t.text :solution
		t.text :see_also
	end unless table_exists?(:plugins)

	create_table :hosts do |t|
		t.string :hostname
		t.string :ip
		t.string :dns
	end unless table_exists?(:hosts)
end

# Define the models
class Scan < ActiveRecord::Base
	has_many :detections
	has_many :plugins, -> { distinct }, through: :detections
	has_many :hosts, -> { distinct }, through: :detections

	validates :filename, presence: true, uniqueness: true
	validates :sha512, presence: true, uniqueness: true
end

class Detection < ActiveRecord::Base
	belongs_to :scan, required: true
	belongs_to :plugin, required: true
	belongs_to :host, required: true
end

class Plugin < ActiveRecord::Base
	has_many :detections
	has_many :scans, -> { distinct }, through: :detections
	has_many :hosts, -> { distinct }, through: :detections
end

class Host < ActiveRecord::Base
	has_many :detections
	has_many :scans, -> { distinct }, through: :detections
end

module Importer
	class Row
		attr_reader :id, :cve, :cvss, :risk, :host, :protocol, :port, :name, :synopsis, :description, :solution, :see_also, :plugin_output

		def initialize(*row)
			raise "Unexpected row length: #{row.count}" unless row.count == 13
			@id = row[0].to_i
			@cve, @cvss, @risk, @host, @protocol = row[1..5]
			@port = row[6].to_i
			@name, @synopsis, @description, @solution, @see_also, @plugin_output = row[7..12]
		end
	end

	def self.import(filename)
		unless filename
			warn "Filename not given; not doing anything."
			exit 1
		end

		data = File.open(filename, 'rb', &:read)
		sha512 = Digest::SHA512.hexdigest data

		begin
			scan = Scan.create!(filename: File.expand_path(filename), sha512: sha512)

			plugins = {}
			hosts = {}
			detections = []

			first = true

			FastCSV.raw_parse(data) do |row|
				if first
					first = false
					next
				end

				row = Row.new(*row)

				if existing = plugins[row.id]
					if existing[:cve] != row.cve
						plugins[row.id][:cve] = "#{plugins[row.id][:cve]}, #{row.cve}"
					end

					raise "Different ID (wat)" if existing[:id] != row.id
					raise "Different CVSS" if existing[:cvss] != row.cvss
					raise "Different Risk" if existing[:risk] != row.risk
					raise "Different Name" if existing[:name] != row.name
					raise "Different Synopsis" if existing[:synopsis] != row.synopsis
					raise "Different Description" if existing[:description] != row.description
					raise "Different Solution" if existing[:solution] != row.solution
					raise "Different See Also: \n\nCurrent:\n\n#{existing[:see_also]}\n\nNew:\n\n#{row.see_also}" if existing[:see_also] != row.see_also
				elsif existing = Plugin.find_by(id: row.id)
					unless existing.cve.match?(row.cve)
						existing.cve = "#{existing.cve}, #{row.cve}"
						existing.save!
					end

					raise "Different ID (wat)" if existing.id != row.id
					raise "Different CVSS" if existing.cvss != row.cvss
					raise "Different Risk" if existing.risk != row.risk
					raise "Different Name" if existing.name != row.name
					raise "Different Synopsis" if existing.synopsis != row.synopsis
					raise "Different Description" if existing.description != row.description
					raise "Different Solution" if existing.solution != row.solution
					raise "Different See Also: \n\nCurrent:\n\n#{existing[:see_also]}\n\nNew:\n\n#{row.see_also}" if existing[:see_also] != row.see_also
				else
					plugins[row.id] = { id: row.id, cve: row.cve, cvss: row.cvss, risk: row.risk, name: row.name, synopsis: row.synopsis, description: row.description, solution: row.solution, see_also: row.see_also }
				end

				unless hosts[row.host] || Host.find_by(hostname: row.host)
					hosts[row.host] = { hostname: row.host }
				end

				detections << { scan_id: scan.id, plugin_id: row.id, hostname: row.host, port: row.port, protocol: row.protocol, plugin_output: row.plugin_output }
			end

			Plugin.bulk_insert(:id, :cve, :cvss, :risk, :name, :synopsis, :description, :solution, :see_also) do |worker|
				plugins.each do |plugin_id, plugin|
					worker.add(plugin)
				end
			end

			Host.bulk_insert do |worker|
				hosts.each.each do |hostname, host|
					worker.add(host)
				end
			end

			hosts = Host.all.map { |host| [host.hostname, host] }.to_h

			Detection.bulk_insert(:scan_id, :plugin_id, :host_id, :port, :protocol, :plugin_output) do |worker|
				detections.each do |detection|
					detection = detection.clone
					detection[:host_id] = hosts[detection[:hostname]].id
					worker.add(detection)
				end
			end
		rescue ActiveRecord::RecordInvalid => e
			warn "Scan (#{filename}) already exists, or otherwise failed validation: #{e}"
		end
	end
end

Importer.import(ARGV.shift)

puts "Imported: #{Plugin.count} plugins, #{Host.count} hosts, and #{Detection.count} detections."

if another = ARGV.shift
	Importer.import(another)

	puts "Imported: #{Plugin.count} plugins, #{Host.count} hosts, and #{Detection.count} detections also."
end

size = ActiveRecord::Base.connection.execute('SELECT page_count * page_size AS size FROM pragma_page_count(), pragma_page_size();').first['size'].to_i

puts "Database has size #{size} bytes (#{(size.to_r / (1024 ** 2)).to_f} MiB)"

binding.pry
